-module('Idris.Idris2.Parser.Rule.Source').
-compile('no_auto_import').
-compile('inline').
-compile({'inline_size',24}).
-export([
  'case--nonEmptyBlockAfter-5139'/5,
  'case--blockWithOptHeaderAfter-4865'/7,
  'case--blockAfter-4711'/5,
  'case--terminator,afterDedent-4388'/5,
  'case--terminator,afterDedent-4353'/5,
  'case--terminator,afterDedent-4322'/4,
  'case--atEndIndent-4284'/3,
  'case--atEnd-4245'/3,
  'case--checkValid-4138'/3,
  'case--checkValid-4112'/3,
  'case--continueF-4013'/4,
  'case--identWithCapital-3801'/2,
  'case--isNotReservedIdent-3757'/2,
  'case--holeName-3673'/1,
  'case--case block in isCapitalisedIdent-3579'/7,
  'case--isCapitalisedIdent-3552'/5,
  'case--namespacedIdent-3519'/1,
  'case--identPart-3505'/1,
  'case--case block in operator-3480'/3,
  'case--operator-3474'/1,
  'case--case block in pragma-3443'/4,
  'case--pragma-3434'/2,
  'case--case block in exactIdent-3401'/4,
  'case--exactIdent-3392'/2,
  'case--case block in keyword-3359'/4,
  'case--keyword-3350'/2,
  'case--case block in symbol-3314'/4,
  'case--symbol-3305'/2,
  'case--aDotIdent-3279'/1,
  'case--interpEnd-3240'/1,
  'case--interpBegin-3226'/1,
  'case--strEnd-3212'/1,
  'case--multilineBegin-3197'/1,
  'case--strBegin-3182'/1,
  'case--strLitLines-3155'/1,
  'case--strLit-3143'/1,
  'case--onOffLit-3121'/1,
  'case--intLit-3107'/1,
  'case--documentation\x{27}-3078'/1,
  'case--case block in constant-3001'/3,
  'case--constant-2997'/1,
  'nested--7137-4747--in--un--restOfBlock'/6,
  'nested--6189-3810--in--un--opNS'/2,
  'nested--6189-3809--in--un--nameNS'/2,
  'nested--5300-2975--in--un--isEOI'/1,
  'nested--6704-4305--in--un--afterSemi'/3,
  'nested--6704-4306--in--un--afterDedent'/4,
  'un--unqualifiedName'/0,
  'un--terminator'/2,
  'un--symbol'/1,
  'un--strLitLines'/0,
  'un--strLit'/0,
  'un--strEnd'/0,
  'un--strBegin'/0,
  'un--simpleStr'/0,
  'un--reservedNames'/0,
  'un--pragma'/1,
  'un--postfixProj'/0,
  'un--operator'/0,
  'un--opNonNS'/0,
  'un--onOffLit'/0,
  'un--nonEmptyBlockAfter'/3,
  'un--nonEmptyBlock'/2,
  'un--namespacedIdent'/0,
  'un--namespaceId'/0,
  'un--nameWithCapital'/1,
  'un--name'/0,
  'un--mustContinue'/2,
  'un--multilineBegin'/0,
  'un--moduleIdent'/0,
  'un--keyword'/1,
  'un--isTerminator'/1,
  'un--isNotReservedIdent'/1,
  'un--isCapitalisedIdent'/1,
  'un--interpEnd'/0,
  'un--interpBegin'/0,
  'un--intLit'/0,
  'un--init'/0,
  'un--identWithCapital'/2,
  'un--identPart'/0,
  'un--holeName'/0,
  'un--exactIdent'/1,
  'un--eoi'/0,
  'un--documentation\x{27}'/0,
  'un--documentation'/0,
  'un--dataTypeName'/0,
  'un--dataConstructorName'/0,
  'un--continueF'/2,
  'un--continue'/1,
  'un--constant'/0,
  'un--checkValid'/2,
  'un--capitalisedName'/0,
  'un--capitalisedIdent'/0,
  'un--blockWithOptHeaderAfter'/5,
  'un--blockEntry'/3,
  'un--blockEntries'/3,
  'un--blockAfter'/3,
  'un--block'/2,
  'un--atEndIndent'/1,
  'un--atEnd'/1,
  'un--aDotIdent'/0,
  'un--SourceEmptyRule'/1,
  'un--Rule'/1,
  'un--IndentInfo'/0
]).
'case--nonEmptyBlockAfter-5139'(V0, V1, V2, V3, V4) -> case V4 of 1 -> {'Idris.Libraries.Text.Parser.Core.SeqEat', 1, ('un--blockEntry'('erased', {'Idris.Parser.Rule.Source.AtPos', V3}, V1)), fun () -> fun (V5) -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 1, ('un--blockEntries'('erased', ('Idris.Idris2.Builtin':'un--snd'('erased', 'erased', V5)), V1)), fun (V6) -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Data.List1.:::', ('Idris.Idris2.Builtin':'un--fst'('erased', 'erased', V5)), V6}} end} end end}; 0 -> {'Idris.Libraries.Text.Parser.Core.Fail', {'Idris.Prelude.Types.Nothing'}, 1, <<"Expected an indented non-empty block"/utf8>>}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--blockWithOptHeaderAfter-4865'(V0, V1, V2, V3, V4, V5, V6) -> case V6 of 0 -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Builtin.MkPair', {'Idris.Prelude.Types.Nothing'}, []}}; 1 -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 1, ('Idris.Idris2.Libraries.Text.Parser':'un--optional'('erased', 'erased', 0, ('un--blockEntry'('erased', {'Idris.Parser.Rule.Source.AtPos', V5}, V3)))), fun (V7) -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 1, ('un--blockEntries'('erased', {'Idris.Parser.Rule.Source.AtPos', V5}, V2)), fun (V8) -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Builtin.MkPair', ('Idris.Idris2.Prelude.Types':'dn--un--map_Functor_Maybe'('erased', 'erased', fun (V9) -> ('Idris.Idris2.Builtin':'un--fst'('erased', 'erased', V9)) end, V7)), V8}} end} end}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--blockAfter-4711'(V0, V1, V2, V3, V4) -> case V4 of 0 -> {'Idris.Libraries.Text.Parser.Core.Empty', []}; 1 -> ('un--blockEntries'('erased', {'Idris.Parser.Rule.Source.AtPos', V3}, V1)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--terminator,afterDedent-4388'(V0, V1, V2, V3, V4) -> case V4 of 0 -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Parser.Rule.Source.AtPos', V2}}; 1 -> {'Idris.Libraries.Text.Parser.Core.Fail', {'Idris.Prelude.Types.Nothing'}, 1, <<"Not the end of a block entry"/utf8>>}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--terminator,afterDedent-4353'(V0, V1, V2, V3, V4) -> case V4 of 0 -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Parser.Rule.Source.AtPos', V2}}; 1 -> {'Idris.Libraries.Text.Parser.Core.Fail', {'Idris.Prelude.Types.Nothing'}, 1, <<"Not the end of a block entry"/utf8>>}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--terminator,afterDedent-4322'(V0, V1, V2, V3) -> case V3 of 0 -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Parser.Rule.Source.AnyIndent'}}; 1 -> {'Idris.Libraries.Text.Parser.Core.Fail', {'Idris.Prelude.Types.Nothing'}, 1, <<"Not the end of a block entry"/utf8>>}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--atEndIndent-4284'(V0, V1, V2) -> case V2 of 0 -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}}; 1 -> {'Idris.Libraries.Text.Parser.Core.Fail', {'Idris.Prelude.Types.Nothing'}, 1, <<"Not the end of a block entry"/utf8>>}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--atEnd-4245'(V0, V1, V2) -> case V2 of 0 -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}}; 1 -> {'Idris.Libraries.Text.Parser.Core.Fail', {'Idris.Prelude.Types.Nothing'}, 1, <<"Not the end of a block entry"/utf8>>}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--checkValid-4138'(V0, V1, V2) -> case V2 of 0 -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}}; 1 -> {'Idris.Libraries.Text.Parser.Core.Fail', {'Idris.Prelude.Types.Nothing'}, 1, <<"Invalid indentation"/utf8>>}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--checkValid-4112'(V0, V1, V2) -> case V2 of 0 -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}}; 1 -> {'Idris.Libraries.Text.Parser.Core.Fail', {'Idris.Prelude.Types.Nothing'}, 1, <<"Invalid indentation"/utf8>>}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--continueF-4013'(V0, V1, V2, V3) -> case V3 of 0 -> V1; 1 -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--identWithCapital-3801'(V0, V1) -> case V1 of 0 -> ('un--isCapitalisedIdent'(V0)); 1 -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--isNotReservedIdent-3757'(V0, V1) -> case V1 of 0 -> {'Idris.Libraries.Text.Parser.Core.Fail', {'Idris.Prelude.Types.Just', case V0 of {'Idris.Libraries.Text.Bounded.MkBounded', E0, E1, E2} -> (fun (V2, V3, V4) -> V4 end(E0, E1, E2)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end}, 1, ('Idris.Idris2.Prelude.Types.String':'un--++'(<<"can\x{27}t use reserved name "/utf8>>, case V0 of {'Idris.Libraries.Text.Bounded.MkBounded', E3, E4, E5} -> (fun (V5, V6, V7) -> V5 end(E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end))}; 1 -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--holeName-3673'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.HoleIdent', E0} -> (fun (V1) -> {'Idris.Prelude.Types.Just', V1} end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--case block in isCapitalisedIdent-3579'(V0, V1, V2, V3, V4, V5, V6) -> case V6 of 0 -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}}; 1 -> V2; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--isCapitalisedIdent-3552'(V0, V1, V2, V3, V4) -> case V1 of <<""/utf8>> -> case V4 of {'Idris.Data.String.StrNil'} -> (fun () -> V3 end()); _ -> case V4 of {'Idris.Data.String.StrCons', E2, E3} -> (fun (V5, V6) -> begin (V7 = (fun (Bin1, Bin2) -> <<Bin1/binary, Bin2/binary>> end(('unicode':'characters_to_binary'([V5 | []])), V6))), ('case--case block in isCapitalisedIdent-3579'(V0, V2, V3, V6, V5, V7, ('Idris.Idris2.Prelude.Basics':'un--||'(('Idris.Idris2.Prelude.Types':'un--isUpper'(V5)), fun () -> ('Idris.Idris2.Prelude.EqOrd':'dn--un-->_Ord_Char'(V5, ('Idris.Idris2.Prelude.Types':'un--chr'(160)))) end)))) end end(E2, E3)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end end; _ -> case V4 of {'Idris.Data.String.StrCons', E0, E1} -> (fun (V8, V9) -> begin (V10 = (fun (Bin1, Bin2) -> <<Bin1/binary, Bin2/binary>> end(('unicode':'characters_to_binary'([V8 | []])), V9))), ('case--case block in isCapitalisedIdent-3579'(V0, V2, V3, V9, V8, V10, ('Idris.Idris2.Prelude.Basics':'un--||'(('Idris.Idris2.Prelude.Types':'un--isUpper'(V8)), fun () -> ('Idris.Idris2.Prelude.EqOrd':'dn--un-->_Ord_Char'(V8, ('Idris.Idris2.Prelude.Types':'un--chr'(160)))) end)))) end end(E0, E1)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end end.
'case--namespacedIdent-3519'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.DotSepIdent', E0, E1} -> (fun (V1, V2) -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkPair', {'Idris.Prelude.Types.Just', V1}, V2}} end(E0, E1)); {'Idris.Parser.Lexer.Source.Ident', E2} -> (fun (V3) -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkPair', {'Idris.Prelude.Types.Nothing'}, V3}} end(E2)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--identPart-3505'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.Ident', E0} -> (fun (V1) -> {'Idris.Prelude.Types.Just', V1} end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--case block in operator-3480'(V0, V1, V2) -> case V2 of 0 -> {'Idris.Prelude.Types.Nothing'}; 1 -> {'Idris.Prelude.Types.Just', {'Idris.Core.Name.UN', V0}}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--operator-3474'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.Symbol', E0} -> (fun (V1) -> begin (V2 = {'Idris.Parser.Lexer.Source.Symbol', V1}), ('case--case block in operator-3480'(V1, V2, ('Idris.Idris2.Prelude.Types':'un--elem'('erased', {'Idris.Prelude.EqOrd.dn--un--__mkEq', fun (V3) -> fun (V4) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V3, V4)) end end, fun (V5) -> fun (V6) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--/=_Eq_String'(V5, V6)) end end}, V1, ('Idris.Idris2.Parser.Lexer.Source':'un--reservedSymbols'()))))) end end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--case block in pragma-3443'(V0, V1, V2, V3) -> case V3 of 0 -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}}; 1 -> {'Idris.Prelude.Types.Nothing'}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--pragma-3434'(V0, V1) -> case V1 of {'Idris.Parser.Lexer.Source.Pragma', E0} -> (fun (V2) -> begin (V3 = {'Idris.Parser.Lexer.Source.Pragma', V2}), ('case--case block in pragma-3443'(V0, V2, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V2, V0)))) end end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--case block in exactIdent-3401'(V0, V1, V2, V3) -> case V3 of 0 -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}}; 1 -> {'Idris.Prelude.Types.Nothing'}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--exactIdent-3392'(V0, V1) -> case V1 of {'Idris.Parser.Lexer.Source.Ident', E0} -> (fun (V2) -> begin (V3 = {'Idris.Parser.Lexer.Source.Ident', V2}), ('case--case block in exactIdent-3401'(V0, V2, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V2, V0)))) end end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--case block in keyword-3359'(V0, V1, V2, V3) -> case V3 of 0 -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}}; 1 -> {'Idris.Prelude.Types.Nothing'}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--keyword-3350'(V0, V1) -> case V1 of {'Idris.Parser.Lexer.Source.Keyword', E0} -> (fun (V2) -> begin (V3 = {'Idris.Parser.Lexer.Source.Keyword', V2}), ('case--case block in keyword-3359'(V0, V2, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V2, V0)))) end end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--case block in symbol-3314'(V0, V1, V2, V3) -> case V3 of 0 -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}}; 1 -> {'Idris.Prelude.Types.Nothing'}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--symbol-3305'(V0, V1) -> case V1 of {'Idris.Parser.Lexer.Source.Symbol', E0} -> (fun (V2) -> begin (V3 = {'Idris.Parser.Lexer.Source.Symbol', V2}), ('case--case block in symbol-3314'(V0, V2, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V2, V0)))) end end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--aDotIdent-3279'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.DotIdent', E0} -> (fun (V1) -> {'Idris.Prelude.Types.Just', V1} end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--interpEnd-3240'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.InterpEnd'} -> (fun () -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}} end()); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--interpBegin-3226'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.InterpBegin'} -> (fun () -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}} end()); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--strEnd-3212'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.StringEnd'} -> (fun () -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}} end()); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--multilineBegin-3197'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.StringBegin', E0} -> (fun (V1) -> case V1 of 0 -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}}; _ -> {'Idris.Prelude.Types.Nothing'} end end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--strBegin-3182'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.StringBegin', E0} -> (fun (V1) -> case V1 of 1 -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}}; _ -> {'Idris.Prelude.Types.Nothing'} end end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--strLitLines-3155'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.StringLit', E0, E1} -> (fun (V1, V2) -> ('Idris.Idris2.Data.List1':'dn--un--traverse_Traversable_List1'('erased', 'erased', 'erased', {'Idris.Prelude.Interfaces.dn--un--__mkApplicative', fun (V3) -> fun (V4) -> fun (V5) -> fun (V6) -> ('Idris.Idris2.Prelude.Types':'dn--un--map_Functor_Maybe'('erased', 'erased', V5, V6)) end end end end, fun (V7) -> fun (V8) -> ('Idris.Idris2.Prelude.Types':'dn--un--pure_Applicative_Maybe'('erased', V8)) end end, fun (V9) -> fun (V10) -> fun (V11) -> fun (V12) -> ('Idris.Idris2.Prelude.Types':'dn--un--<*>_Applicative_Maybe'('erased', 'erased', V11, V12)) end end end end}, fun (V13) -> ('Idris.Idris2.Parser.Support':'un--escape'(V1, ('Idris.Idris2.Prelude.Types':'un--fastPack'(V13)))) end, ('Idris.Idris2.Libraries.Data.List.Extra':'un--splitAfter'('erased', fun (V14) -> ('Idris.Idris2.Prelude.Types':'un--isNL'(V14)) end, ('Idris.Idris2.Data.String':'un--fastUnpack'(V2)))))) end(E0, E1)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--strLit-3143'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.StringLit', E0, E1} -> (fun (V1, V2) -> ('Idris.Idris2.Parser.Support':'un--escape'(V1, V2)) end(E0, E1)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--onOffLit-3121'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.Ident', E0} -> (fun (V1) -> case V1 of <<"on"/utf8>> -> {'Idris.Prelude.Types.Just', 0}; <<"off"/utf8>> -> {'Idris.Prelude.Types.Just', 1}; _ -> {'Idris.Prelude.Types.Nothing'} end end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--intLit-3107'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.IntegerLit', E0} -> (fun (V1) -> {'Idris.Prelude.Types.Just', V1} end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--documentation\x{27}-3078'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.DocComment', E0} -> (fun (V1) -> {'Idris.Prelude.Types.Just', V1} end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'case--case block in constant-3001'(V0, V1, V2) -> case V2 of {'Idris.Prelude.Types.Nothing'} -> (fun () -> {'Idris.Prelude.Types.Nothing'} end()); {'Idris.Prelude.Types.Just', E0} -> (fun (V3) -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Ch', V3}} end(E0)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'case--constant-2997'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.CharLit', E0} -> (fun (V1) -> begin (V2 = {'Idris.Parser.Lexer.Source.CharLit', V1}), ('case--case block in constant-3001'(V1, V2, ('Idris.Idris2.Parser.Support':'un--getCharLit'(V1)))) end end(E0)); {'Idris.Parser.Lexer.Source.DoubleLit', E1} -> (fun (V3) -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Db', V3}} end(E1)); {'Idris.Parser.Lexer.Source.IntegerLit', E2} -> (fun (V4) -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.BI', V4}} end(E2)); {'Idris.Parser.Lexer.Source.Ident', E3} -> (fun (V5) -> case V5 of <<"Char"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.CharType'}}; <<"Double"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.DoubleType'}}; <<"Int"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.IntType'}}; <<"Integer"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.IntegerType'}}; <<"Bits8"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Bits8Type'}}; <<"Bits16"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Bits16Type'}}; <<"Bits32"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Bits32Type'}}; <<"Bits64"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Bits64Type'}}; <<"String"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.StringType'}}; _ -> {'Idris.Prelude.Types.Nothing'} end end(E3)); _ -> {'Idris.Prelude.Types.Nothing'} end.
'nested--7137-4747--in--un--restOfBlock'(V0, V1, V2, V3, V4, V5) -> case V5 of {'Idris.Prelude.Types.Just', E0} -> (fun (V6) -> case V6 of {'Idris.Builtin.MkPair', E1, E2} -> (fun (V7, V8) -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 0, ('un--blockEntries'('erased', V8, V2)), fun (V9) -> {'Idris.Libraries.Text.Parser.Core.ThenEat', 1, ('un--symbol'(<<"}"/utf8>>)), fun () -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Builtin.MkPair', {'Idris.Prelude.Types.Just', V7}, V9}} end} end} end(E1, E2)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end end(E0)); {'Idris.Prelude.Types.Nothing'} -> (fun () -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 0, ('un--blockEntries'('erased', {'Idris.Parser.Rule.Source.AnyIndent'}, V2)), fun (V10) -> {'Idris.Libraries.Text.Parser.Core.ThenEat', 1, ('un--symbol'(<<"}"/utf8>>)), fun () -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Builtin.MkPair', {'Idris.Prelude.Types.Nothing'}, V10}} end} end} end()); _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'nested--6189-3810--in--un--opNS'(V0, V1) -> {'Idris.Libraries.Text.Parser.Core.ThenEmpty', 1, 0, ('un--isCapitalisedIdent'(('Idris.Idris2.Prelude.Interfaces':'un--<$>'('erased', 'erased', 'erased', fun (V2) -> fun (V3) -> fun (V4) -> fun (V5) -> ('Idris.Idris2.Libraries.Text.Bounded':'dn--un--map_Functor_WithBounds'('erased', 'erased', V4, V5)) end end end end, fun (V6) -> ('Idris.Idris2.Builtin':'un--snd'('erased', 'erased', V6)) end, V1)))), begin (V12 = ('Idris.Idris2.Prelude.Basics':'un--uncurry'('erased', 'erased', 'erased', fun (V7) -> fun (V8) -> ('Idris.Idris2.Core.Name.Namespace':'un--mkNestedNamespace'(V7, V8)) end end, case V1 of {'Idris.Libraries.Text.Bounded.MkBounded', E0, E1, E2} -> (fun (V9, V10, V11) -> V9 end(E0, E1, E2)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end))), {'Idris.Libraries.Text.Parser.Core.ThenEat', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 0 end)), ('un--symbol'(<<".("/utf8>>)), fun () -> {'Idris.Libraries.Text.Parser.Core.SeqEat', 0, {'Idris.Libraries.Text.Parser.Core.Alt', 0, 0, ('un--operator'()), fun () -> ('un--postfixProj'()) end}, fun () -> fun (V13) -> {'Idris.Libraries.Text.Parser.Core.ThenEat', 1, ('un--symbol'(<<")"/utf8>>)), fun () -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Core.Name.NS', V12, V13}} end} end end} end} end}.
'nested--6189-3809--in--un--nameNS'(V0, V1) -> begin (V7 = ('Idris.Idris2.Prelude.Interfaces':'un--<$>'('erased', 'erased', 'erased', fun (V2) -> fun (V3) -> fun (V4) -> fun (V5) -> ('Idris.Idris2.Libraries.Text.Bounded':'dn--un--map_Functor_WithBounds'('erased', 'erased', V4, V5)) end end end end, fun (V6) -> ('Idris.Idris2.Builtin':'un--snd'('erased', 'erased', V6)) end, V1))), {'Idris.Libraries.Text.Parser.Core.ThenEmpty', 1, 1, ('un--identWithCapital'(V0, V7)), {'Idris.Libraries.Text.Parser.Core.ThenEmpty', 1, 1, ('un--isNotReservedIdent'(V7)), {'Idris.Libraries.Text.Parser.Core.Empty', ('Idris.Idris2.Prelude.Basics':'un--uncurry'('erased', 'erased', 'erased', fun (V8) -> fun (V9) -> ('Idris.Idris2.Core.Name':'un--mkNamespacedName'(V8, V9)) end end, case V1 of {'Idris.Libraries.Text.Bounded.MkBounded', E0, E1, E2} -> (fun (V10, V11, V12) -> V10 end(E0, E1, E2)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end))}}} end.
'nested--5300-2975--in--un--isEOI'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.EndInput'} -> (fun () -> 0 end()); _ -> 1 end.
'nested--6704-4305--in--un--afterSemi'(V0, V1, V2) -> case V2 of {'Idris.Parser.Rule.Source.AnyIndent'} -> (fun () -> {'Idris.Parser.Rule.Source.AnyIndent'} end()); {'Idris.Parser.Rule.Source.AtPos', E0} -> (fun (V3) -> {'Idris.Parser.Rule.Source.AfterPos', V3} end(E0)); {'Idris.Parser.Rule.Source.AfterPos', E1} -> (fun (V4) -> {'Idris.Parser.Rule.Source.AfterPos', V4} end(E1)); {'Idris.Parser.Rule.Source.EndOfBlock'} -> (fun () -> {'Idris.Parser.Rule.Source.EndOfBlock'} end()); _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'nested--6704-4306--in--un--afterDedent'(V0, V1, V2, V3) -> case V2 of {'Idris.Parser.Rule.Source.AnyIndent'} -> (fun () -> ('case--terminator,afterDedent-4322'(V0, V1, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V3, V0)))) end()); {'Idris.Parser.Rule.Source.AfterPos', E0} -> (fun (V4) -> ('case--terminator,afterDedent-4353'(V0, V1, V4, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V3, V0)))) end(E0)); {'Idris.Parser.Rule.Source.AtPos', E1} -> (fun (V5) -> ('case--terminator,afterDedent-4388'(V0, V1, V5, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V3, V0)))) end(E1)); {'Idris.Parser.Rule.Source.EndOfBlock'} -> (fun () -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Parser.Rule.Source.EndOfBlock'}} end()); _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'un--unqualifiedName'() -> ('un--identPart'()).
'un--terminator'(V0, V1) -> {'Idris.Libraries.Text.Parser.Core.Alt', 1, ('Idris.Idris2.Prelude.Basics':'un--&&'(('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 1 end)), fun () -> ('Idris.Idris2.Prelude.Basics':'un--&&'(('Idris.Idris2.Prelude.Basics':'un--||'(1, fun () -> 1 end)), fun () -> 1 end)) end)), {'Idris.Libraries.Text.Parser.Core.ThenEmpty', 1, 1, ('un--eoi'()), {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Parser.Rule.Source.EndOfBlock'}}}, fun () -> {'Idris.Libraries.Text.Parser.Core.Alt', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 1 end)), ('Idris.Idris2.Prelude.Basics':'un--&&'(('Idris.Idris2.Prelude.Basics':'un--||'(1, fun () -> 1 end)), fun () -> 1 end)), {'Idris.Libraries.Text.Parser.Core.ThenEat', 1, ('un--symbol'(<<";"/utf8>>)), fun () -> {'Idris.Libraries.Text.Parser.Core.Empty', ('nested--6704-4305--in--un--afterSemi'(V1, V0, V0))} end}, fun () -> {'Idris.Libraries.Text.Parser.Core.Alt', ('Idris.Idris2.Prelude.Basics':'un--||'(1, fun () -> 1 end)), 1, {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 1, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V2) -> ('nested--6704-4306--in--un--afterDedent'(V1, V0, V0, V2)) end}, fun () -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Parser.Rule.Source.EndOfBlock'}} end} end} end}.
'un--symbol'(V0) -> {'Idris.Libraries.Text.Parser.Core.Terminal', ('Idris.Idris2.Prelude.Types.String':'un--++'(<<"Expected \x{27}"/utf8>>, ('Idris.Idris2.Prelude.Types.String':'un--++'(V0, <<"\x{27}"/utf8>>)))), fun (V1) -> case V1 of {'Idris.Parser.Lexer.Source.Symbol', E0} -> (fun (V2) -> begin (V3 = {'Idris.Parser.Lexer.Source.Symbol', V2}), ('case--case block in symbol-3314'(V0, V2, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V2, V0)))) end end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--strLitLines'() -> {'Idris.Libraries.Text.Parser.Core.Terminal', <<"Expected string literal"/utf8>>, fun (V0) -> case V0 of {'Idris.Parser.Lexer.Source.StringLit', E0, E1} -> (fun (V1, V2) -> ('Idris.Idris2.Data.List1':'dn--un--traverse_Traversable_List1'('erased', 'erased', 'erased', {'Idris.Prelude.Interfaces.dn--un--__mkApplicative', fun (V3) -> fun (V4) -> fun (V5) -> fun (V6) -> ('Idris.Idris2.Prelude.Types':'dn--un--map_Functor_Maybe'('erased', 'erased', V5, V6)) end end end end, fun (V7) -> fun (V8) -> ('Idris.Idris2.Prelude.Types':'dn--un--pure_Applicative_Maybe'('erased', V8)) end end, fun (V9) -> fun (V10) -> fun (V11) -> fun (V12) -> ('Idris.Idris2.Prelude.Types':'dn--un--<*>_Applicative_Maybe'('erased', 'erased', V11, V12)) end end end end}, fun (V13) -> ('Idris.Idris2.Parser.Support':'un--escape'(V1, ('Idris.Idris2.Prelude.Types':'un--fastPack'(V13)))) end, ('Idris.Idris2.Libraries.Data.List.Extra':'un--splitAfter'('erased', fun (V14) -> ('Idris.Idris2.Prelude.Types':'un--isNL'(V14)) end, ('Idris.Idris2.Data.String':'un--fastUnpack'(V2)))))) end(E0, E1)); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--strLit'() -> {'Idris.Libraries.Text.Parser.Core.Terminal', <<"Expected string literal"/utf8>>, fun (V0) -> case V0 of {'Idris.Parser.Lexer.Source.StringLit', E0, E1} -> (fun (V1, V2) -> ('Idris.Idris2.Parser.Support':'un--escape'(V1, V2)) end(E0, E1)); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--strEnd'() -> {'Idris.Libraries.Text.Parser.Core.Terminal', <<"Expected string end"/utf8>>, fun (V0) -> case V0 of {'Idris.Parser.Lexer.Source.StringEnd'} -> (fun () -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}} end()); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--strBegin'() -> {'Idris.Libraries.Text.Parser.Core.Terminal', <<"Expected string begin"/utf8>>, fun (V0) -> case V0 of {'Idris.Parser.Lexer.Source.StringBegin', E0} -> (fun (V1) -> case V1 of 1 -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}}; _ -> {'Idris.Prelude.Types.Nothing'} end end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--simpleStr'() -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 1 end)), 0, ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_((Grammar $tok) $c)'('erased', 'erased', 'erased', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 1 end)), fun (V0) -> fun (V1) -> V0 end end, {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 0, 1, ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_((Grammar $tok) $c)'('erased', 'erased', 'erased', 0, fun (V2) -> fun (V3) -> V3 end end, {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 0, 1, ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_((Grammar $tok) $c)'('erased', 'erased', 'erased', 0, fun (V4) -> fun (V5) -> V5 end end, ('un--strBegin'()))), fun (V6) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_((Grammar $tok) $c)'('erased', 'erased', 'erased', 1, V6, {'Idris.Libraries.Text.Parser.Core.Commit'})) end})), fun (V7) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_((Grammar $tok) $c)'('erased', 'erased', 'erased', 1, V7, ('Idris.Idris2.Libraries.Text.Parser':'un--option'('erased', 'erased', 0, <<""/utf8>>, ('un--strLit'()))))) end})), fun (V8) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_((Grammar $tok) $c)'('erased', 'erased', 'erased', 0, V8, ('un--strEnd'()))) end}.
'un--reservedNames'() -> [<<"Type"/utf8>> | [<<"Int"/utf8>> | [<<"Integer"/utf8>> | [<<"Bits8"/utf8>> | [<<"Bits16"/utf8>> | [<<"Bits32"/utf8>> | [<<"Bits64"/utf8>> | [<<"String"/utf8>> | [<<"Char"/utf8>> | [<<"Double"/utf8>> | [<<"Lazy"/utf8>> | [<<"Inf"/utf8>> | [<<"Force"/utf8>> | [<<"Delay"/utf8>> | []]]]]]]]]]]]]]].
'un--pragma'(V0) -> {'Idris.Libraries.Text.Parser.Core.Terminal', ('Idris.Idris2.Prelude.Types.String':'un--++'(<<"Expected pragma "/utf8>>, V0)), fun (V1) -> case V1 of {'Idris.Parser.Lexer.Source.Pragma', E0} -> (fun (V2) -> begin (V3 = {'Idris.Parser.Lexer.Source.Pragma', V2}), ('case--case block in pragma-3443'(V0, V2, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V2, V0)))) end end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--postfixProj'() -> ('Idris.Idris2.Prelude.Interfaces':'un--<$>'('erased', 'erased', 'erased', fun (V0) -> fun (V1) -> fun (V2) -> fun (V3) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_((Grammar $tok) $c)'('erased', 'erased', 'erased', 0, V2, V3)) end end end end, fun (V4) -> {'Idris.Core.Name.RF', V4} end, ('un--aDotIdent'()))).
'un--operator'() -> {'Idris.Libraries.Text.Parser.Core.Terminal', <<"Expected operator"/utf8>>, fun (V0) -> case V0 of {'Idris.Parser.Lexer.Source.Symbol', E0} -> (fun (V1) -> begin (V2 = {'Idris.Parser.Lexer.Source.Symbol', V1}), ('case--case block in operator-3480'(V1, V2, ('Idris.Idris2.Prelude.Types':'un--elem'('erased', {'Idris.Prelude.EqOrd.dn--un--__mkEq', fun (V3) -> fun (V4) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V3, V4)) end end, fun (V5) -> fun (V6) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--/=_Eq_String'(V5, V6)) end end}, V1, ('Idris.Idris2.Parser.Lexer.Source':'un--reservedSymbols'()))))) end end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--opNonNS'() -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 0 end)), 0, ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_((Grammar $tok) $c)'('erased', 'erased', 'erased', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 0 end)), fun (V0) -> fun (V1) -> V0 end end, {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 0, 0, ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_((Grammar $tok) $c)'('erased', 'erased', 'erased', 0, fun (V2) -> fun (V3) -> V3 end end, ('un--symbol'(<<"("/utf8>>)))), fun (V4) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_((Grammar $tok) $c)'('erased', 'erased', 'erased', 0, V4, {'Idris.Libraries.Text.Parser.Core.Alt', 0, 0, ('un--operator'()), fun () -> ('un--postfixProj'()) end})) end})), fun (V5) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_((Grammar $tok) $c)'('erased', 'erased', 'erased', 0, V5, ('un--symbol'(<<")"/utf8>>)))) end}.
'un--onOffLit'() -> {'Idris.Libraries.Text.Parser.Core.Terminal', <<"Expected on or off"/utf8>>, fun (V0) -> case V0 of {'Idris.Parser.Lexer.Source.Ident', E0} -> (fun (V1) -> case V1 of <<"on"/utf8>> -> {'Idris.Prelude.Types.Just', 0}; <<"off"/utf8>> -> {'Idris.Prelude.Types.Just', 1}; _ -> {'Idris.Prelude.Types.Nothing'} end end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--nonEmptyBlockAfter'(V0, V1, V2) -> {'Idris.Libraries.Text.Parser.Core.Alt', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 0 end)), ('Idris.Idris2.Prelude.Basics':'un--||'(1, fun () -> 0 end)), {'Idris.Libraries.Text.Parser.Core.ThenEat', 0, ('un--symbol'(<<"{"/utf8>>)), fun () -> {'Idris.Libraries.Text.Parser.Core.ThenEmpty', 1, 0, {'Idris.Libraries.Text.Parser.Core.Commit'}, {'Idris.Libraries.Text.Parser.Core.SeqEat', 0, ('un--blockEntry'('erased', {'Idris.Parser.Rule.Source.AnyIndent'}, V2)), fun () -> fun (V3) -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 0, ('un--blockEntries'('erased', ('Idris.Idris2.Builtin':'un--snd'('erased', 'erased', V3)), V2)), fun (V4) -> {'Idris.Libraries.Text.Parser.Core.ThenEat', 1, ('un--symbol'(<<"}"/utf8>>)), fun () -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Data.List1.:::', ('Idris.Idris2.Builtin':'un--fst'('erased', 'erased', V3)), V4}} end} end} end end}} end}, fun () -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 0, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V5) -> ('case--nonEmptyBlockAfter-5139'('erased', V2, V1, V5, ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V5, V1)))) end} end}.
'un--nonEmptyBlock'(V0, V1) -> {'Idris.Libraries.Text.Parser.Core.Alt', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 0 end)), ('Idris.Idris2.Prelude.Basics':'un--||'(1, fun () -> 0 end)), {'Idris.Libraries.Text.Parser.Core.ThenEat', 0, ('un--symbol'(<<"{"/utf8>>)), fun () -> {'Idris.Libraries.Text.Parser.Core.ThenEmpty', 1, 0, {'Idris.Libraries.Text.Parser.Core.Commit'}, {'Idris.Libraries.Text.Parser.Core.SeqEat', 0, ('un--blockEntry'('erased', {'Idris.Parser.Rule.Source.AnyIndent'}, V1)), fun () -> fun (V2) -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 0, ('un--blockEntries'('erased', ('Idris.Idris2.Builtin':'un--snd'('erased', 'erased', V2)), V1)), fun (V3) -> {'Idris.Libraries.Text.Parser.Core.ThenEat', 1, ('un--symbol'(<<"}"/utf8>>)), fun () -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Data.List1.:::', ('Idris.Idris2.Builtin':'un--fst'('erased', 'erased', V2)), V3}} end} end} end end}} end}, fun () -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 0, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V4) -> {'Idris.Libraries.Text.Parser.Core.SeqEat', 1, ('un--blockEntry'('erased', {'Idris.Parser.Rule.Source.AtPos', V4}, V1)), fun () -> fun (V5) -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 1, ('un--blockEntries'('erased', ('Idris.Idris2.Builtin':'un--snd'('erased', 'erased', V5)), V1)), fun (V6) -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Data.List1.:::', ('Idris.Idris2.Builtin':'un--fst'('erased', 'erased', V5)), V6}} end} end end} end} end}.
'un--namespacedIdent'() -> {'Idris.Libraries.Text.Parser.Core.Terminal', <<"Expected namespaced name"/utf8>>, fun (V0) -> case V0 of {'Idris.Parser.Lexer.Source.DotSepIdent', E0, E1} -> (fun (V1, V2) -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkPair', {'Idris.Prelude.Types.Just', V1}, V2}} end(E0, E1)); {'Idris.Parser.Lexer.Source.Ident', E2} -> (fun (V3) -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkPair', {'Idris.Prelude.Types.Nothing'}, V3}} end(E2)); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--namespaceId'() -> {'Idris.Libraries.Text.Parser.Core.SeqEat', 1, {'Idris.Libraries.Text.Parser.Core.Bounds', ('un--namespacedIdent'())}, fun () -> fun (V0) -> {'Idris.Libraries.Text.Parser.Core.ThenEmpty', 1, 1, ('un--isCapitalisedIdent'(('Idris.Idris2.Prelude.Interfaces':'un--<$>'('erased', 'erased', 'erased', fun (V1) -> fun (V2) -> fun (V3) -> fun (V4) -> ('Idris.Idris2.Libraries.Text.Bounded':'dn--un--map_Functor_WithBounds'('erased', 'erased', V3, V4)) end end end end, fun (V5) -> ('Idris.Idris2.Builtin':'un--snd'('erased', 'erased', V5)) end, V0)))), {'Idris.Libraries.Text.Parser.Core.Empty', ('Idris.Idris2.Prelude.Basics':'un--uncurry'('erased', 'erased', 'erased', fun (V6) -> fun (V7) -> ('Idris.Idris2.Core.Name.Namespace':'un--mkNestedNamespace'(V6, V7)) end end, case V0 of {'Idris.Libraries.Text.Bounded.MkBounded', E0, E1, E2} -> (fun (V8, V9, V10) -> V8 end(E0, E1, E2)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end))}} end end}.
'un--nameWithCapital'(V0) -> {'Idris.Libraries.Text.Parser.Core.Alt', 0, 0, ('un--opNonNS'()), fun () -> {'Idris.Libraries.Text.Parser.Core.SeqEat', 1, {'Idris.Libraries.Text.Parser.Core.Bounds', ('un--namespacedIdent'())}, fun () -> fun (V1) -> {'Idris.Libraries.Text.Parser.Core.Alt', 0, 1, ('nested--6189-3810--in--un--opNS'(V0, V1)), fun () -> ('nested--6189-3809--in--un--nameNS'(V0, V1)) end} end end} end}.
'un--name'() -> ('un--nameWithCapital'(1)).
'un--mustContinue'(V0, V1) -> case V1 of {'Idris.Prelude.Types.Nothing'} -> (fun () -> ('un--continueF'({'Idris.Libraries.Text.Parser.Core.Fail', {'Idris.Prelude.Types.Nothing'}, 0, <<"Unexpected end of expression"/utf8>>}, V0)) end()); {'Idris.Prelude.Types.Just', E0} -> (fun (V2) -> ('un--continueF'({'Idris.Libraries.Text.Parser.Core.Fail', {'Idris.Prelude.Types.Nothing'}, 0, ('Idris.Idris2.Prelude.Types.String':'un--++'(<<"Expected \x{27}"/utf8>>, ('Idris.Idris2.Prelude.Types.String':'un--++'(V2, <<"\x{27}"/utf8>>))))}, V0)) end(E0)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'un--multilineBegin'() -> {'Idris.Libraries.Text.Parser.Core.Terminal', <<"Expected multiline string begin"/utf8>>, fun (V0) -> case V0 of {'Idris.Parser.Lexer.Source.StringBegin', E0} -> (fun (V1) -> case V1 of 0 -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}}; _ -> {'Idris.Prelude.Types.Nothing'} end end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--moduleIdent'() -> ('Idris.Idris2.Prelude.Interfaces':'un--<$>'('erased', 'erased', 'erased', fun (V0) -> fun (V1) -> fun (V2) -> fun (V3) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_((Grammar $tok) $c)'('erased', 'erased', 'erased', 0, V2, V3)) end end end end, fun (V4) -> ('Idris.Idris2.Core.Name.Namespace':'un--nsAsModuleIdent'(V4)) end, ('un--namespaceId'()))).
'un--keyword'(V0) -> {'Idris.Libraries.Text.Parser.Core.Terminal', ('Idris.Idris2.Prelude.Types.String':'un--++'(<<"Expected \x{27}"/utf8>>, ('Idris.Idris2.Prelude.Types.String':'un--++'(V0, <<"\x{27}"/utf8>>)))), fun (V1) -> case V1 of {'Idris.Parser.Lexer.Source.Keyword', E0} -> (fun (V2) -> begin (V3 = {'Idris.Parser.Lexer.Source.Keyword', V2}), ('case--case block in keyword-3359'(V0, V2, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V2, V0)))) end end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--isTerminator'(V0) -> case V0 of {'Idris.Parser.Lexer.Source.Symbol', E0} -> (fun (V1) -> case V1 of <<","/utf8>> -> 0; <<"]"/utf8>> -> 0; <<";"/utf8>> -> 0; <<"}"/utf8>> -> 0; <<")"/utf8>> -> 0; <<"|"/utf8>> -> 0; <<"**"/utf8>> -> 0; _ -> 1 end end(E0)); {'Idris.Parser.Lexer.Source.Keyword', E1} -> (fun (V2) -> case V2 of <<"in"/utf8>> -> 0; <<"then"/utf8>> -> 0; <<"else"/utf8>> -> 0; <<"where"/utf8>> -> 0; _ -> 1 end end(E1)); {'Idris.Parser.Lexer.Source.EndInput'} -> (fun () -> 0 end()); _ -> 1 end.
'un--isNotReservedIdent'(V0) -> ('case--isNotReservedIdent-3757'(V0, ('Idris.Idris2.Prelude.Types':'un--elem'('erased', {'Idris.Prelude.EqOrd.dn--un--__mkEq', fun (V1) -> fun (V2) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V1, V2)) end end, fun (V3) -> fun (V4) -> ('Idris.Idris2.Prelude.EqOrd':'dn--un--/=_Eq_String'(V3, V4)) end end}, case V0 of {'Idris.Libraries.Text.Bounded.MkBounded', E0, E1, E2} -> (fun (V5, V6, V7) -> V5 end(E0, E1, E2)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end, ('un--reservedNames'()))))).
'un--isCapitalisedIdent'(V0) -> begin (V4 = case V0 of {'Idris.Libraries.Text.Bounded.MkBounded', E0, E1, E2} -> (fun (V1, V2, V3) -> V1 end(E0, E1, E2)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end), begin (V8 = case V0 of {'Idris.Libraries.Text.Bounded.MkBounded', E3, E4, E5} -> (fun (V5, V6, V7) -> V7 end(E3, E4, E5)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end), begin (V9 = {'Idris.Libraries.Text.Parser.Core.Fail', {'Idris.Prelude.Types.Just', V8}, 1, ('Idris.Idris2.Prelude.Types.String':'un--++'(<<"Expected a capitalised identifier, got: "/utf8>>, V4))}), ('case--isCapitalisedIdent-3552'(V0, V4, V8, V9, ('Idris.Idris2.Data.String':'un--strM'(V4)))) end end end.
'un--interpEnd'() -> {'Idris.Libraries.Text.Parser.Core.Terminal', <<"Expected string interp end"/utf8>>, fun (V0) -> case V0 of {'Idris.Parser.Lexer.Source.InterpEnd'} -> (fun () -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}} end()); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--interpBegin'() -> {'Idris.Libraries.Text.Parser.Core.Terminal', <<"Expected string interp begin"/utf8>>, fun (V0) -> case V0 of {'Idris.Parser.Lexer.Source.InterpBegin'} -> (fun () -> {'Idris.Prelude.Types.Just', {'Idris.Builtin.MkUnit'}} end()); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--intLit'() -> {'Idris.Libraries.Text.Parser.Core.Terminal', <<"Expected integer literal"/utf8>>, fun (V0) -> case V0 of {'Idris.Parser.Lexer.Source.IntegerLit', E0} -> (fun (V1) -> {'Idris.Prelude.Types.Just', V1} end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--init'() -> 0.
'un--identWithCapital'(V0, V1) -> case V0 of 0 -> ('un--isCapitalisedIdent'(V1)); 1 -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}}; _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'un--identPart'() -> {'Idris.Libraries.Text.Parser.Core.Terminal', <<"Expected name"/utf8>>, fun (V0) -> case V0 of {'Idris.Parser.Lexer.Source.Ident', E0} -> (fun (V1) -> {'Idris.Prelude.Types.Just', V1} end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--holeName'() -> {'Idris.Libraries.Text.Parser.Core.Terminal', <<"Expected hole name"/utf8>>, fun (V0) -> case V0 of {'Idris.Parser.Lexer.Source.HoleIdent', E0} -> (fun (V1) -> {'Idris.Prelude.Types.Just', V1} end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--exactIdent'(V0) -> {'Idris.Libraries.Text.Parser.Core.Terminal', ('Idris.Idris2.Prelude.Types.String':'un--++'(<<"Expected "/utf8>>, V0)), fun (V1) -> case V1 of {'Idris.Parser.Lexer.Source.Ident', E0} -> (fun (V2) -> begin (V3 = {'Idris.Parser.Lexer.Source.Ident', V2}), ('case--case block in exactIdent-3401'(V0, V2, V3, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_String'(V2, V0)))) end end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--eoi'() -> ('Idris.Idris2.Prelude.Interfaces':'un--ignore'('erased', 'erased', fun (V0) -> fun (V1) -> fun (V2) -> fun (V3) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_((Grammar $tok) $c)'('erased', 'erased', 'erased', 1, V2, V3)) end end end end, {'Idris.Libraries.Text.Parser.Core.NextIs', <<"Expected end of input"/utf8>>, fun (V4) -> ('nested--5300-2975--in--un--isEOI'(V4)) end})).
'un--documentation\x{27}'() -> {'Idris.Libraries.Text.Parser.Core.Terminal', <<"Expected documentation comment"/utf8>>, fun (V0) -> case V0 of {'Idris.Parser.Lexer.Source.DocComment', E0} -> (fun (V1) -> {'Idris.Prelude.Types.Just', V1} end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--documentation'() -> ('Idris.Idris2.Prelude.Interfaces':'un--<$>'('erased', 'erased', 'erased', fun (V0) -> fun (V1) -> fun (V2) -> fun (V3) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_((Grammar $tok) $c)'('erased', 'erased', 'erased', 0, V2, V3)) end end end end, fun (V4) -> ('Idris.Idris2.Libraries.Data.String.Extra':'un--unlines'(('Idris.Idris2.Data.List1':'un--forget'('erased', V4)))) end, ('Idris.Idris2.Libraries.Text.Parser':'un--some'('erased', 'erased', ('un--documentation\x{27}'()))))).
'un--dataTypeName'() -> {'Idris.Libraries.Text.Parser.Core.Alt', 0, 0, ('un--opNonNS'()), fun () -> ('un--capitalisedName'()) end}.
'un--dataConstructorName'() -> {'Idris.Libraries.Text.Parser.Core.Alt', 0, 0, ('un--opNonNS'()), fun () -> ('Idris.Idris2.Prelude.Interfaces':'un--<$>'('erased', 'erased', 'erased', fun (V0) -> fun (V1) -> fun (V2) -> fun (V3) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_((Grammar $tok) $c)'('erased', 'erased', 'erased', 0, V2, V3)) end end end end, fun (V4) -> {'Idris.Core.Name.UN', V4} end, ('un--capitalisedIdent'()))) end}.
'un--continueF'(V0, V1) -> {'Idris.Libraries.Text.Parser.Core.Alt', 1, ('Idris.Idris2.Prelude.Basics':'un--&&'(0, fun () -> 1 end)), {'Idris.Libraries.Text.Parser.Core.ThenEmpty', 1, 1, ('un--eoi'()), V0}, fun () -> {'Idris.Libraries.Text.Parser.Core.Alt', 0, 1, {'Idris.Libraries.Text.Parser.Core.ThenEat', 1, ('un--keyword'(<<"where"/utf8>>)), fun () -> V0 end}, fun () -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 1, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V2) -> ('case--continueF-4013'(V1, V0, V2, ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V2, V1)))) end} end} end}.
'un--continue'(V0) -> ('un--continueF'({'Idris.Libraries.Text.Parser.Core.Fail', {'Idris.Prelude.Types.Nothing'}, 1, <<"Unexpected end of expression"/utf8>>}, V0)).
'un--constant'() -> {'Idris.Libraries.Text.Parser.Core.Terminal', <<"Expected constant"/utf8>>, fun (V0) -> case V0 of {'Idris.Parser.Lexer.Source.CharLit', E0} -> (fun (V1) -> begin (V2 = {'Idris.Parser.Lexer.Source.CharLit', V1}), ('case--case block in constant-3001'(V1, V2, ('Idris.Idris2.Parser.Support':'un--getCharLit'(V1)))) end end(E0)); {'Idris.Parser.Lexer.Source.DoubleLit', E1} -> (fun (V3) -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Db', V3}} end(E1)); {'Idris.Parser.Lexer.Source.IntegerLit', E2} -> (fun (V4) -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.BI', V4}} end(E2)); {'Idris.Parser.Lexer.Source.Ident', E3} -> (fun (V5) -> case V5 of <<"Char"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.CharType'}}; <<"Double"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.DoubleType'}}; <<"Int"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.IntType'}}; <<"Integer"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.IntegerType'}}; <<"Bits8"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Bits8Type'}}; <<"Bits16"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Bits16Type'}}; <<"Bits32"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Bits32Type'}}; <<"Bits64"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.Bits64Type'}}; <<"String"/utf8>> -> {'Idris.Prelude.Types.Just', {'Idris.Core.TT.StringType'}}; _ -> {'Idris.Prelude.Types.Nothing'} end end(E3)); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--checkValid'(V0, V1) -> case V0 of {'Idris.Parser.Rule.Source.AnyIndent'} -> (fun () -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Builtin.MkUnit'}} end()); {'Idris.Parser.Rule.Source.AtPos', E0} -> (fun (V2) -> ('case--checkValid-4112'(V2, V1, ('Idris.Idris2.Prelude.EqOrd':'dn--un--==_Eq_Int'(V1, V2)))) end(E0)); {'Idris.Parser.Rule.Source.AfterPos', E1} -> (fun (V3) -> ('case--checkValid-4138'(V3, V1, ('Idris.Idris2.Prelude.EqOrd':'dn--un-->=_Ord_Int'(V1, V3)))) end(E1)); {'Idris.Parser.Rule.Source.EndOfBlock'} -> (fun () -> {'Idris.Libraries.Text.Parser.Core.Fail', {'Idris.Prelude.Types.Nothing'}, 1, <<"End of block"/utf8>>} end()); _ -> ('erlang':'throw'("Error: Unreachable branch")) end.
'un--capitalisedName'() -> ('un--nameWithCapital'(0)).
'un--capitalisedIdent'() -> {'Idris.Libraries.Text.Parser.Core.SeqEat', 1, {'Idris.Libraries.Text.Parser.Core.Bounds', ('un--identPart'())}, fun () -> fun (V0) -> {'Idris.Libraries.Text.Parser.Core.ThenEmpty', 1, 1, ('un--isCapitalisedIdent'(V0)), {'Idris.Libraries.Text.Parser.Core.ThenEmpty', 1, 1, ('un--isNotReservedIdent'(V0)), {'Idris.Libraries.Text.Parser.Core.Empty', case V0 of {'Idris.Libraries.Text.Bounded.MkBounded', E0, E1, E2} -> (fun (V1, V2, V3) -> V1 end(E0, E1, E2)); _ -> ('erlang':'throw'("Error: Unreachable branch")) end}}} end end}.
'un--blockWithOptHeaderAfter'(V0, V1, V2, V3, V4) -> {'Idris.Libraries.Text.Parser.Core.Alt', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 0 end)), 1, {'Idris.Libraries.Text.Parser.Core.ThenEat', 0, ('un--symbol'(<<"{"/utf8>>)), fun () -> {'Idris.Libraries.Text.Parser.Core.ThenEmpty', 1, 0, {'Idris.Libraries.Text.Parser.Core.Commit'}, {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 0, ('Idris.Idris2.Libraries.Text.Parser':'un--optional'('erased', 'erased', 0, ('un--blockEntry'('erased', {'Idris.Parser.Rule.Source.AnyIndent'}, V3)))), fun (V5) -> ('nested--7137-4747--in--un--restOfBlock'('erased', 'erased', V4, V3, V2, V5)) end}} end}, fun () -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 1, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V6) -> ('case--blockWithOptHeaderAfter-4865'('erased', 'erased', V4, V3, V2, V6, ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V6, V2)))) end} end}.
'un--blockEntry'(V0, V1, V2) -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 0, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V3) -> {'Idris.Libraries.Text.Parser.Core.ThenEmpty', 1, 0, ('un--checkValid'(V1, V3)), {'Idris.Libraries.Text.Parser.Core.SeqEat', 1, (V2(V3)), fun () -> fun (V4) -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 1, ('un--terminator'(V1, V3)), fun (V5) -> {'Idris.Libraries.Text.Parser.Core.Empty', {'Idris.Builtin.MkPair', V4, V5}} end} end end}} end}.
'un--blockEntries'(V0, V1, V2) -> {'Idris.Libraries.Text.Parser.Core.Alt', 1, ('Idris.Idris2.Prelude.Basics':'un--&&'(0, fun () -> 1 end)), {'Idris.Libraries.Text.Parser.Core.ThenEmpty', 1, 1, ('un--eoi'()), {'Idris.Libraries.Text.Parser.Core.Empty', []}}, fun () -> {'Idris.Libraries.Text.Parser.Core.Alt', 0, 1, {'Idris.Libraries.Text.Parser.Core.SeqEat', 1, ('un--blockEntry'('erased', V1, V2)), fun () -> fun (V3) -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 1, ('un--blockEntries'('erased', ('Idris.Idris2.Builtin':'un--snd'('erased', 'erased', V3)), V2)), fun (V4) -> {'Idris.Libraries.Text.Parser.Core.Empty', [('Idris.Idris2.Builtin':'un--fst'('erased', 'erased', V3)) | V4]} end} end end}, fun () -> {'Idris.Libraries.Text.Parser.Core.Empty', []} end} end}.
'un--blockAfter'(V0, V1, V2) -> {'Idris.Libraries.Text.Parser.Core.Alt', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 0 end)), 1, {'Idris.Libraries.Text.Parser.Core.ThenEat', 0, ('un--symbol'(<<"{"/utf8>>)), fun () -> {'Idris.Libraries.Text.Parser.Core.ThenEmpty', 1, 0, {'Idris.Libraries.Text.Parser.Core.Commit'}, {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 0, ('un--blockEntries'('erased', {'Idris.Parser.Rule.Source.AnyIndent'}, V2)), fun (V3) -> {'Idris.Libraries.Text.Parser.Core.ThenEat', 1, ('un--symbol'(<<"}"/utf8>>)), fun () -> {'Idris.Libraries.Text.Parser.Core.Empty', V3} end} end}} end}, fun () -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 1, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V4) -> ('case--blockAfter-4711'('erased', V2, V1, V4, ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V4, V1)))) end} end}.
'un--block'(V0, V1) -> {'Idris.Libraries.Text.Parser.Core.Alt', ('Idris.Idris2.Prelude.Basics':'un--||'(0, fun () -> 0 end)), ('Idris.Idris2.Prelude.Basics':'un--||'(1, fun () -> 1 end)), {'Idris.Libraries.Text.Parser.Core.ThenEat', 0, ('un--symbol'(<<"{"/utf8>>)), fun () -> {'Idris.Libraries.Text.Parser.Core.ThenEmpty', 1, 0, {'Idris.Libraries.Text.Parser.Core.Commit'}, {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 0, ('un--blockEntries'('erased', {'Idris.Parser.Rule.Source.AnyIndent'}, V1)), fun (V2) -> {'Idris.Libraries.Text.Parser.Core.ThenEat', 1, ('un--symbol'(<<"}"/utf8>>)), fun () -> {'Idris.Libraries.Text.Parser.Core.Empty', V2} end} end}} end}, fun () -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 1, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V3) -> ('un--blockEntries'('erased', {'Idris.Parser.Rule.Source.AtPos', V3}, V1)) end} end}.
'un--atEndIndent'(V0) -> {'Idris.Libraries.Text.Parser.Core.Alt', 1, 1, ('un--eoi'()), fun () -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 1, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V1) -> ('case--atEndIndent-4284'(V0, V1, ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V1, V0)))) end} end}.
'un--atEnd'(V0) -> {'Idris.Libraries.Text.Parser.Core.Alt', 1, 1, ('un--eoi'()), fun () -> {'Idris.Libraries.Text.Parser.Core.Alt', 1, 1, ('Idris.Idris2.Prelude.Interfaces':'un--ignore'('erased', 'erased', fun (V1) -> fun (V2) -> fun (V3) -> fun (V4) -> ('Idris.Idris2.Libraries.Text.Parser.Core':'dn--un--map_Functor_((Grammar $tok) $c)'('erased', 'erased', 'erased', 1, V3, V4)) end end end end, {'Idris.Libraries.Text.Parser.Core.NextIs', <<"Expected end of block"/utf8>>, fun (V5) -> ('un--isTerminator'(V5)) end})), fun () -> {'Idris.Libraries.Text.Parser.Core.SeqEmpty', 1, 1, ('Idris.Idris2.Parser.Rule.Common':'un--column'({'Idris.Parser.Lexer.Source.Token'})), fun (V6) -> ('case--atEnd-4245'(V0, V6, ('Idris.Idris2.Prelude.EqOrd':'dn--un--<=_Ord_Int'(V6, V0)))) end} end} end}.
'un--aDotIdent'() -> {'Idris.Libraries.Text.Parser.Core.Terminal', <<"Expected dot+identifier"/utf8>>, fun (V0) -> case V0 of {'Idris.Parser.Lexer.Source.DotIdent', E0} -> (fun (V1) -> {'Idris.Prelude.Types.Just', V1} end(E0)); _ -> {'Idris.Prelude.Types.Nothing'} end end}.
'un--SourceEmptyRule'(V0) -> ('Idris.Idris2.Parser.Rule.Common':'un--EmptyRule'({'Idris.Parser.Lexer.Source.Token'}, V0)).
'un--Rule'(V0) -> ('Idris.Idris2.Parser.Rule.Common':'un--Rule'({'Idris.Parser.Lexer.Source.Token'}, V0)).
'un--IndentInfo'() -> {'Idris.Int'}.
